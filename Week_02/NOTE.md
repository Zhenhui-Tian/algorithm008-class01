# 哈希函数
##基础
### 什么是哈希表
哈希表使用一个数组的特性（按照下标访问的时候时间复杂度为O(1).具体来讲，通过一个函数（hash 函数），将值转换成对应的数组下标。如果发生两个值的下标是一样的，我们将在这个下标的内存位置存储一个链表。
### 散列表的核心问题
散列函数的确定
散列冲突的解决
### 什么是hash 函数
hash 函数的形式 hash（key）

### 什么是hash collision（哈希碰撞）
不同value的值经过hash 函数过后得到了相同的key
### 如何解决散列冲突
**开放寻址法**：如果发生冲突，我们就按照一定的步长往后遍历数组直到找到空闲位置
开放寻址法的查找方式有哪些，
线性查找，平方查找，或者是多重hash（如果第一个hash函数冲突就用第二个，直到不冲突）
开放寻址法的删除有什么特殊
当找到删除的元素时 我们不能直接设置为空，因为当再次查找的时候，如果查找到这个位置，是空，我们就判定没有所查元素。所以我们一般都采取标记法
开发寻址法的增删查改时间复杂度为多少
增O(1)
删O(1)
查最坏O(n): 发生冲突的时候可能遍历整个数组

**链表法**：数组对应的是一个槽，每个槽都是一个链表，hash 值相同的value 存储在一个链表中（利用了升维的思想）
链表法的增删查改时间复杂度是多少
增O(1)
删O(1)
查O(k)：理想情况下 k = 元素个数/ 散列长度（也就是value 都平均分布）
### 什么是装载因子
数组已占位置长度 / 数组总长度，装载因子越大表示冲突越大，表示性能越低
### 如何设计一个工业级的的hash表
动态扩容

设计合理的hash 函数

解决hash碰撞攻击

### 什么时候使用开放寻址法，什么时候使用链表式哈希表
存储的单个数据占用空间小就用开放寻址法，因为链表的指针会占用一定的空间（指针占用空间和数数据占用空间相等
对于链表式的哈希有什么改进的方法，改进的条件是什么
将链表换为树，这样查询时间能由O(n)到O(logn)
words 里面检查错误单词是怎样实现的（hash表的应用）
将整个字典在内存中存储为hash 表，用户每敲一个单词就查找，找不到证明拼写错误。
## code

### hash 和字典的关系
HashMap 的操作
HashMap和Hashtable的区别
HashMap 允许空值并且不同步 unsynchronized
HashMap 不保证插入的顺序
### 影响HashMap 性能的两个参数
capacity，
load factor（默认0.75）
### 如何在并发的时候使用hashmap
Map m = Collections.synchronizedMap(new HashMap(...))
### Java set 文档
#### set 是什么怎么使用
set 就是我们数学上理解的一个集合（无相同值的集合）
set在java 中是以接口的形式出现的，所以 使用方法为。
主要就是两个功能，添加，查找（因为底层是hash所以查找为O(1)）
#### java mutable object vs immutable objects
mutable objects have setter which can change field value
immutable object doesn't have setter.
### java map 文档
#### 介绍一下java 中的map文档
java 中map 是一个接口， 存储key-value，的键值对，key不可重复，一个key对应一个value

map 允许三种查询 查key 查value 查 key-value

map的key如果是mutable object 将会导致行为不确定

map 不允许用map对象作为key


#### map vs dictionary
java中map是一个接口，dictionary是一个抽象类

#### java final keyword
final varible 不能被修改
final method 不能被子类重写
final class 不能被继承，也就是没有子类
#### java && vs &
两者都是and的意思，但是&&判断一个条件为false过后就不会接着往下看了，&要看完所有condition
java transient

# 树
## 树的基础概念有哪些
  节点：父节点，子节点，兄弟节点，根节点，叶节点
  节点高度： 节点到叶子节点的最长路径
  节点的深度：从root到这个节点的边数
  节点的层数：节点的深度加一
  树高： 根节点的高度
## 二叉树
### 二叉树的特点：
  a node have at most two children
###  二叉树有几种存储方式
  链表存储
  数组存储（root 存在1和root存在0两种情况）
###  二叉树的分类
  满二叉树：
  叶子节点全在最底层
  除了叶子节点其他节点
  
  完全二叉树
  叶子节点全部靠左
  除了最后一层，其他节点层数都要有2（注意这里说的是节点层，不是叶子节点层）
###  完全二叉树有什么特点
  用数组存储的时候节约内存，因为数组中间没有null 的情况，也就是说不会出现数组中间index 为null。
###  二叉树的遍历
  前，中， 后
  
  这里的前中后是 父节点和左右节点的相对位置 前（父左右) 中（左父右）后（左右中）

###  如何用数组表示二叉树，以及如何查询对应点的父节点子节点
  设该节点下标为index，
  那么他的父节点为(index-1)/ 2,
  右节点索引为 2*index + 2,
  左节点索引为2*index+1.
##  二叉查找树
###  与二叉树的区别
  left < root < right， all value in left tree < root < all value in
  right tree

# 堆
堆有大根堆小根堆，可以实现O(1)的时间复杂度得到最大值或者最小值。

# 图
##  定义
  有点有边的数据结构
##  度
  入度：指入，
  出度：指出，
  无向图出度=入度
##  如何存储图
  邻接矩阵，
  邻接表（数组存点，后面接链表储存与之相连的脚
##  权
  边的长度不是0和1 而是一个具体的数值
##  常见算法
  DFS
  BFS


