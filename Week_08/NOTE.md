排序

- 如何分析一个排序算法的好坏
  - 时间复杂度（包括最好，最差，平均，因为排序数据量小 所以不会省略系数以及常数项）
  - 稳定性
  - 原地排序算法，空间复杂度
- 什么是一个排序算法的稳定性
  - 如果两个相同的数在排序前后保持相对位置不变，我们就说他是稳定的
- 什么是原地排序算法
  - 空间复杂度为O(1)
- 为什么都是 O(n^2) 相对于冒泡排序我们在工业上却喜欢用插入排序
  - 冒泡排序每次都会交换（三个复杂语句） 而插入排序只有一个赋值语句，追求极致的性能优化，对比这两个的话 一个是3K 一个是 K （K个数字）
- 算法的稳定性高有什么好处？
  - 对于要求对对象的两个属性进行排序时，好写代码
  - 举个例子，将订单对象排序， 金额从大到小，如果金额相同，相同金额由下单时间从早到晚排序
  - 如果排序算法是稳定的，我们可以先按下单时间排序，然后按金额排序就好了。而不用写代码在相同金额的区域排序。
- 冒泡排序
- 插入排序
- 选择排序
- 归并排序
  - 归并排序的思想
    - 分治的思想
    - 将n个数分为n/2个数，分别排序，然后 合并两个排好序的数
  - 归并排序的实现步骤（代码）
    - 、、、
  - 归并排序的时间复杂度分析
    - 写出递归公式： T(n) = 2 * T(n/2) + k （k 是merge的时间复杂度）
- 快速排序
  - 快速排序的思想
    - 利用pivot，将一组数据分为相对有序的两段
- 快排解决第K大的数的思路
- 桶排序
  - 桶排序的思路
    - 将n个数据分到m个桶里面（每个桶之间相对有序）例如 1-100 为一个，101-200 为一个
    - 桶内数据进行快排。然后按照桶的顺序依次取出
  - 桶排序适用的场景